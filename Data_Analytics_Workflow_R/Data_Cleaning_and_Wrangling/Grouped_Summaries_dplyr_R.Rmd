---
title: "L05: Group-By and Summarise"
subtitle: "Chapters 3.5 and 5 in R4DS"
author: "Nadeem Hassan"
output: pdf_document
---

```{r}
library(tidyverse)
```

Just to remind you, this is what the `mpg` data frame looks like:

```{r}
glimpse(mpg)
```

## Review

The `dplyr` functions are a powerful set of functions for data manipulation.

-   They all take a data frame as the first argument, and output a data frame.
    -   `|>` Perfect for pipes!
    -   They *do not* modify the original data frame.
-   Each is a verb describing what action it's taking.

## Changing the Data

In all examples last class, we just outputted the result to the screen. We may want to actually change the data permamently (recall that in R there is no undo button).

1.  Change in-place: re-write our original data with a modified version

-   Do this *rarely* and with great care!

2.  Create a copy: Make a new object with your changes.

-   Do this often, but make the names meaningful!

Recall that the `cyl` column in `mpg` is either 4, 5, 6, or 8. It cannot be anything other than those values, and will never be in-between. It makes sense to change `cyl` to a factor permanently.

Conversely, we might want to change `displ` to be in units of gallons instead of liters and add overall fuel efficiency.

```{r}
# Change cyl permanently.
mpg <- mpg |>
  mutate(cyl = factor(cyl))

# New data with displ in gallons (imperial units)
# Also adding overall fuel efficiency
mpg_imp <- mpg |>
  mutate(
    displ = 0.2199693 * displ,
    overall = 0.45 * hwy + 0.55 * cty
  )
```

## More `select`ing

There are many cases where we just want the numeric columns. We could do this manually with `select(displ, year, cyl, cty, hwy)`, but the tidyverse has some special ways to do this built-in.

```{r}
mpg |>
  select(where(is.numeric)) |>
  glimpse()
```

Similar approaches exist for `is.character` and `is.factor`.

## `summarise()`

This `dplyr` function is slightly different from the others. The other functions moved around rows and added/removed columns, but left the data intact. `summarise()` produces different data!

```{r}
mpg |>
  filter(cyl == 5) |>
  summarise(
    mean_hwy = mean(hwy),
    quartile_1 = quantile(hwy, 0.25),
    median_hwy = median(hwy),
    number_of_cars = n()
  )
```

The data frame that comes out of this has completely new column names!

-   The names could be anything.
-   The values are the output of a function that *summarises* the data.
-   `n()` is a special function that returns the number of rows in the current data frame.
    -   In this case, we're only looking at 5 cylinder cars.

Just like with `select()`, we can use `summarise()` on all numeric columns. Here's the mean of every column that is numeric:

```{r}
mpg |>
  filter(cyl == 5) |>
  summarise(
    across(where(is.numeric), mean),
    count = n()
  )
```

Note that the code above also finds the number of rows again. I like including this information because it tells me how much information the summary statistics are based on.

The following is much more involved and I needed to check a vignette and a help page several times to get it to work, but it's nice to know that it works.

```{r}
mpg |>
  filter(cyl == 5) |>
  summarise(
    across(
      .cols = where(is.numeric),
      .fns = list(mean, median, sd)
    ),
    count = n()
  )
```

Note that:

-   All of the argument names in `across()` start with a "`.`". Usually, if you come across names that start with a `.` then you're deeper into R's functionality, far beyond what most users will use.
    -   In this case, `across()` assumes that the condition comes first and the function comes second, so you can just pass the arguments by position. I added the argument names for clarity (see Chapter 4 of R4DS), but it's not necessary.
-   The functions in `.fns` are just the R objects - they're not in quotes!
    -   Because of this, the output has the format `colname_fnnumber`, where `fnnumber` is the function number (1 for the first function, 2 for second, and 3 for third).
    -   We can avoid this with a named list, i.e. by using `.fns = list("this_is_the_mean" = mean, "heyLookItsTheMedian" = median, "ess-dee" = sd)` (obviously, the names in quotation marks can be anything - using the names "mean", "median", and "sd" make the most sense, but that makes it confusing for teaching).

## `group_by()`

In the examples above, I filtered to only include 5 cylinder cars. What if I want the summary statistics for all cars, but separated by the number of cylinders? Can you guess, based on the title of this section?

```{r}
mpg |>
  group_by(cyl) |>
  summarise(mean_hwy = mean(hwy), number_obs = n())
```

Notice that there's still a column labelled `cyl` in the output!

```{r}
mpg |>
  group_by(cyl, class) |>
  summarise(mean_hwy = mean(hwy), sd_hwy = sd(hwy), number_obs = n())
```

-   The standard deviation (sd) of `hwy` is NA for four cylinder minivans because there's only one observation in that group!

The `group_by()` function creates a **grouped data frame**, which is a special thing. For each group there's a complete separate data frame (similar to the facets in `ggplot2`), and any `dplyr` functions will be applied *separately* to each group. This works for *any* `dplyr` function.

For example, here's a chunk of code to rank the *least* fuel efficient cars within each class. Note that I'm using `mpg_imp` because it has the `overall` fuel efficiency.

```{r}
mpg_imp |>
  group_by(class) |>
  # mutate() will calculate the rank separately for each group
  mutate(overall_rank = rank(overall)) |>
  # No longer need the groupings
  ungroup() |>
  # This makes it easy to navigate the output
  select(manufacturer, model, year, class, overall, overall_rank) |>
  # Let's see the top cars! (low mpg = bad fuel efficiency)
  arrange(overall_rank)
```

Similarly, we can do something like the following to `filter()` the data within groups:

```{r}
# The most fuel efficient car for each number of cylinders
mpg_imp |>
  group_by(cyl) |>
  filter(overall == max(overall))
```

```{r eval=FALSE}
# The top 10% of cars in each cylinder class
mpg_imp |>
  group_by(cyl) |>
  filter(???)
  
```

## Activity: How do I get the best fuel efficiency?

Suppose I want to buy a car and fuel efficiency is my main concern. Also suppose that it's 2008 and electric cars aren't yet a thing. What should I look for when I go to a dealership?

Use the following code cell (or see MyLS if RStudio isn't working for you yet) to use the code we've learned to:

-   Find the class/drv/fuel type/whatever that "tends to have" the best fuel efficiency.
-   Demonstrate this with a plot (or plots).

```{r}

```